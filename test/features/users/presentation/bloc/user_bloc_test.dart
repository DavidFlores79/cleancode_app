import 'package:bloc_test/bloc_test.dart';
import 'package:cleancode_app/core/errors/failures.dart';
import 'package:cleancode_app/features/users/domain/entities/pageable_users.dart';
import 'package:cleancode_app/features/users/domain/entities/user.dart';
import 'package:cleancode_app/features/users/domain/usecases/get_all_users_usecase.dart';
import 'package:cleancode_app/features/users/presentation/bloc/user_bloc.dart';
import 'package:cleancode_app/features/users/presentation/bloc/user_event.dart';
import 'package:cleancode_app/features/users/presentation/bloc/user_state.dart';
import 'package:dartz/dartz.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

// Mock dependencies
@GenerateMocks([
  GetAllUsersUsecase,
  // Add other use cases if needed for a full UserBloc test suite,
  // but for pagination, GetAllUsersUsecase is primary.
])
import 'user_bloc_test.mocks.dart'; // Generated by build_runner

void main() {
  late MockGetAllUsersUsecase mockGetAllUsersUsecase;
  late UserBloc userBloc;

  // Sample User entities for testing
  final tUser1 = User(id: '1', name: 'User One', email: 'user1@example.com');
  final tUser2 = User(id: '2', name: 'User Two', email: 'user2@example.com');
  final tUser3 = User(id: '3', name: 'User Three', email: 'user3@example.com');

  setUp(() {
    mockGetAllUsersUsecase = MockGetAllUsersUsecase();
    // Provide all required use cases for UserBloc constructor
    // For this test, we only focus on mockGetAllUsersUsecase.
    // Others can be simple mocks if not directly used in pagination tests.
    userBloc = UserBloc(
      getAllUsersUseCase: mockGetAllUsersUsecase,
      // Mock other use cases with basic stubs if necessary
      getOneUserUseCase: MockGetOneUserUsecase(),
      createUserUseCase: MockCreateUserUsecase(),
      updateUserUseCase: MockUpdateUserUsecase(),
      deleteUserUseCase: MockDeleteUserUsecase(),
      searchUsersUsecase: MockSearchUsersUsecase(),
    );
  });

  tearDown(() {
    userBloc.close();
  });

  test('initial state should be UserInitialState', () {
    expect(userBloc.state, equals(UserInitialState()));
  });

  group('GetAllUsers Event - First Page', () {
    final tPageableUsersPage1 = PageableUsers(
      page: 1,
      pageSize: 1,
      totalItems: 2,
      data: [tUser1],
    );

    blocTest<UserBloc, UserState>(
      'emits [UserLoadingState, GetAllUsersSuccessState] when GetAllUsers is added for the first page and use case succeeds.',
      build: () {
        when(mockGetAllUsersUsecase.call(params: anyNamed('params')))
            .thenAnswer((_) async => Right(tPageableUsersPage1));
        return userBloc;
      },
      act: (bloc) => bloc.add(GetAllUsers(page: 1, pageSize: 1)),
      expect: () => [
        UserLoadingState(),
        GetAllUsersSuccessState(tPageableUsersPage1),
      ],
      verify: (_) {
        expect(userBloc.currentPage, 2); // Incremented after successful fetch
        expect(userBloc.loadedUsers.length, 1);
        expect(userBloc.loadedUsers[0].id, tUser1.id);
        expect(userBloc.totalItems, tPageableUsersPage1.totalItems);
        verify(mockGetAllUsersUsecase.call(params: argThat(
          isA<GetAllUsersParams>()
              .having((p) => p.page, 'page', 1)
              .having((p) => p.pageSize, 'pageSize', 1),
          named: 'params'
        ))).called(1);
      },
    );
  });

  group('GetAllUsers Event - Load More Pages', () {
    final tInitialUsers = [User(id: '0', name: 'Initial User')];
    final tPageableUsersPage1 = PageableUsers(
        page: 1, pageSize: 1, totalItems: 3, data: [tUser1]);
    final tPageableUsersPage2 = PageableUsers(
        page: 2, pageSize: 1, totalItems: 3, data: [tUser2]);

    // This state represents the BLoC after page 1 has been loaded
    final initialStateWithPage1Loaded = UserBloc(
      getAllUsersUseCase: mockGetAllUsersUsecase,
      getOneUserUseCase: MockGetOneUserUsecase(),
      createUserUseCase: MockCreateUserUsecase(),
      updateUserUseCase: MockUpdateUserUsecase(),
      deleteUserUseCase: MockDeleteUserUsecase(),
      searchUsersUsecase: MockSearchUsersUsecase(),
    )
      ..currentPage = 2 // Next page to fetch is 2
      ..totalItems = tPageableUsersPage1.totalItems
      // UserBloc internal loadedUsers are UserModels, PageableUsers in state has User
      ..loadedUsers = [UserModel.fromDomain(tUser1)];


    blocTest<UserBloc, UserState>(
      'emits [UserLoadingMoreState, GetAllUsersSuccessState with appended users] when loading more pages.',
      build: () {
        when(mockGetAllUsersUsecase.call(params: anyNamed('params')))
            .thenAnswer((_) async => Right(tPageableUsersPage2));
        return initialStateWithPage1Loaded;
      },
      act: (bloc) => bloc.add(GetAllUsers(page: bloc.currentPage, pageSize: 1)), // Request page 2
      expect: () {
        // The state should contain all users loaded so far (tUser1 + tUser2)
        final expectedCombinedData = [tUser1, tUser2];
        final expectedPageableUsers = PageableUsers(
          page: 2, // Current page fetched
          pageSize: tPageableUsersPage2.pageSize,
          totalItems: tPageableUsersPage2.totalItems,
          data: expectedCombinedData,
        );
        return [
          UserLoadingMoreState(),
          GetAllUsersSuccessState(expectedPageableUsers),
        ];
      },
      verify: (bloc) {
        expect(bloc.currentPage, 3);
        expect(bloc.loadedUsers.length, 2);
        expect(bloc.loadedUsers.map((e) => e.id).toList(), equals(['1', '2']));
         verify(mockGetAllUsersUsecase.call(params: argThat(
          isA<GetAllUsersParams>()
              .having((p) => p.page, 'page', 2)
              .having((p) => p.pageSize, 'pageSize', 1),
          named: 'params'
        ))).called(1);
      },
    );
  });

  group('GetAllUsers Event - Max Items Reached', () {
    final tPageableUsersMaxReached = PageableUsers(
      page: 1,
      pageSize: 2,
      totalItems: 2, // totalItems is equal to items in data list
      data: [tUser1, tUser2],
    );

    blocTest<UserBloc, UserState>(
      'emits [UserLoadingState, UserMaxReachedState] when total items are reached.',
      build: () {
        when(mockGetAllUsersUsecase.call(params: anyNamed('params')))
            .thenAnswer((_) async => Right(tPageableUsersMaxReached));
        return userBloc;
      },
      act: (bloc) => bloc.add(GetAllUsers(page: 1, pageSize: 2)),
      expect: () => [
        UserLoadingState(),
        UserMaxReachedState(tPageableUsersMaxReached),
      ],
      verify: (_) {
        expect(userBloc.currentPage, 2);
        expect(userBloc.loadedUsers.length, 2);
        expect(userBloc.totalItems, 2);
      },
    );
  });

  group('GetAllUsers Event - Use Case Failure', () {
    final tFailure = ServerFailure(message: 'Network Error');

    blocTest<UserBloc, UserState>(
      'emits [UserLoadingState, UserFailureState] when use case returns a failure.',
      build: () {
        when(mockGetAllUsersUsecase.call(params: anyNamed('params')))
            .thenAnswer((_) async => Left(tFailure));
        return userBloc;
      },
      act: (bloc) => bloc.add(GetAllUsers(page: 1, pageSize: 10)),
      expect: () => [
        UserLoadingState(),
        UserFailureState(tFailure.message),
      ],
      verify: (_) {
        // currentPage should not increment on failure
        expect(userBloc.currentPage, 1);
      }
    );
  });
}

// Minimal mocks for other use cases not under test for pagination
class MockGetOneUserUsecase extends Mock implements GetOneUserUsecase {}
class MockCreateUserUsecase extends Mock implements CreateUserUsecase {}
class MockUpdateUserUsecase extends Mock implements UpdateUserUsecase {}
class MockDeleteUserUsecase extends Mock implements DeleteUserUsecase {}
class MockSearchUsersUsecase extends Mock implements SearchUsersUsecase {}
// Note: If these usecases were part of the UserBloc's constructor and not nullable,
// you'd need to provide instances of these mocks when creating UserBloc.
// The @GenerateMocks at the top is for build_runner to generate these.
// For this specific test, if build_runner is not run, these manual minimal mocks are needed.
// If build_runner is run, user_bloc_test.mocks.dart will contain these and they should be imported.
// For simplicity in this environment, explicit minimal mocks are defined here.
// In a real project, ensure build_runner has generated user_bloc_test.mocks.dart.
